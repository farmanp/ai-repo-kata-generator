Kata Progression System Framework for Job Postings and Code Repositories
Introduction: What Is a Kata Progression System?
A kata progression system is a structured learning framework inspired by martial arts kata – repeated, focused practice routines – and adapted to technical skills. In software development, a code kata is a programming exercise practiced repeatedly to improve skill through deliberate practice
apiumhub.com
. The goal is to preserve and refine techniques by repetition until they become second-nature
apiumhub.com
. Unlike one-off tutorials, katas emphasize learning by doing in a progressive manner, enabling developers to apply and adapt techniques confidently under different circumstances
apiumhub.com
. Notably, code katas aren’t just for beginners; even mid-level and senior developers benefit from them, using katas to learn new techniques and polish existing skills
apiumhub.com
. In our context, a kata progression system means taking content (like a job posting or a code repository) and turning it into a series of practice exercises (katas) that build up a learner’s competencies step by step. This approach leverages principles of deliberate learning – focused, goal-oriented practice with feedback – to fast-track an end user’s skill development. It aligns with the idea from Toyota’s Improvement Kata: breaking a complex goal into smaller, intermediate targets and practicing new skills until they become habit
premieragile.com
. In essence, we design a learning path where each kata is a module focusing on one aspect, and together they progress the learner from foundational knowledge to advanced mastery. Key characteristics of the kata framework:
Tech and Domain Agnostic: The framework is not tied to any specific programming language or domain. It works by analyzing content for skills and concepts, which could be in web development, data science, DevOps, or any field, and generating relevant exercises. The approach is general – it extracts skills from a job description or codebase and creates practice scenarios around them, regardless of the tech stack.
Focus on Mid/Senior Level Skills: While beginners can use katas, our emphasis is on mid-level and senior professionals. This means the katas will target more advanced competencies – e.g. system design, debugging complex issues, refactoring legacy code – to simulate the challenges experienced engineers face on the job. (Advanced kata topics often include high-level design and complex problem-solving, such as applying design patterns or working with legacy systems
katanation.com
.) The progression will assume a base level of knowledge and push it further.
Outcome-Oriented Format: We deliver the katas in a structured format (e.g. Markdown or YAML for easy readability and integration). Each kata exercise will include clearly defined components: the prompt or challenge, the scenario context, the specifications for completion, and if needed, a workflow or hints. These components act as our “Context Engineering” deliverables – assembling everything the learner (or an AI assistant) needs to understand the task and attempt a solution. In other words, we’re not just giving a single instruction; we’re designing the entire context around the task (background info, tools, criteria), much like context engineering in AI, which is about providing a model with all the relevant information it needs to perform well
datacamp.com
.
Before diving into the application on job postings and code repos, let’s clarify the core principles that make this kata progression system effective.
Core Principles: Deliberate Practice and Scaffolding
At the heart of the kata framework is deliberate practice. This means each exercise is intentionally crafted to focus on a specific skill or concept, performed with full concentration, repeated for reinforcement, and ideally coupled with immediate feedback
katanation.com
. Rather than passively reading or watching, the learner actively practices the skill. Key aspects of deliberate practice as applied here include:
Single Focus: Each kata targets one primary skill or concept at a time. For example, one kata might focus on writing a database query efficiently, another on implementing a design pattern correctly. This “one primary focus point” rule is critical
katanation.com
– it prevents cognitive overload and lets the learner hone one ability before layering more complexity.
Repetition & Mastery: The kata can be practiced multiple times or in variants, to reinforce learning. As the Apiumhub article notes, the aim is to practice techniques until execution becomes reflex-like, but always with an eye on doing it right (quality over rote repetition)
apiumhub.com
.
Immediate Feedback: Wherever possible, the kata provides feedback. This could be through automated tests (in coding katas), solution walkthroughs, or mentor review. Immediate feedback helps correct mistakes and refine technique
katanation.com
. For instance, a kata might include unit tests that must pass, giving the user quick confirmation that their solution meets the spec.
In addition to deliberate practice, we apply scaffolding in our system design. Scaffolding means providing a supportive structure for learning new concepts, then gradually removing support as competence grows. Kata Culture exemplifies this by giving developers a structured environment (rules and routines) to take a new concept and apply/adapt/extend it, thus expediting the tough transition from theory to practical skill
katanation.com
. In our framework, scaffolding is achieved by the careful sequencing of katas:
Progressive Difficulty: The exercises are ordered from simpler to more complex. Early katas establish fundamental knowledge and are scoped narrowly. Later katas increase in complexity or combine multiple skills. This mirrors the idea of breaking down a challenge into intermediate goals
premieragile.com
. The learner gains confidence with the basics, then tackles harder scenarios as they progress. By the end, they can handle tasks comparable to real job challenges.
Contextual Gradation: We start with high-support contexts (detailed guidance, smaller problem scope) and gradually move to low-support contexts (open-ended problems, less guidance), as the learner becomes more fluent. Think of it as gradually removing training wheels. For example, an initial kata might spell out which module of a codebase to modify and provide an outline of a solution; a later kata might simply state a problem and let the learner decide how to approach the entire codebase. This builds self-sufficiency.
Toolsets and Habits: The framework encourages building habits that experts use. Katas can instill techniques like Test-Driven Development, debugging strategies, or architectural thinking as repeatable routines. By practicing these in multiple exercises, the learner integrates them into their daily toolkit. Over time, proficiency becomes fluency – as KataNation puts it, moving from consciously knowing a skill to using it as an automatic tool
katanation.com
.
Overall, these principles ensure the kata progression system isn’t just a random collection of exercises, but a cohesive learning journey. Developers following it will repeatedly engage with content in a way that is intentional, structured, and optimized for growth, rather than ad-hoc practice. Such a system has been observed to greatly increase skill maturity and even team productivity when applied in organizations
katanation.com
. With the foundation set, let’s explore how to apply this framework to the two primary content sources in question: job postings and code repositories.
Applying the Framework to Job Postings
Job postings are rich with information about the skills and knowledge required for a role. We can leverage that to create targeted katas that prepare a learner (or job candidate) for the position. The process is as follows: 1. Extract Key Skills and Requirements: First, we parse the job posting to identify the core competencies it demands. This can be done manually or with NLP techniques (indeed, skill extraction from job ads is a well-explored NLP task
adu.autonomy.work
). For example, a software job posting typically lists programming languages, frameworks, tools, and also soft skills or domain knowledge. It may also describe typical tasks (“maintain legacy systems”, “optimize performance”, “collaborate via code reviews”, etc.). Using an AI to assist here is an option – large language models can scan the posting and list the skills and responsibilities mentioned
adu.autonomy.work
. The output of this step is a skills matrix for the job: e.g., “Proficient in Python and Django”, “Experience with RESTful API design and security”, “Knowledge of machine learning algorithms”, “Ability to troubleshoot production issues”, etc. 2. Design Katas for Each Skill/Area: For each important skill or requirement identified, we create one or more kata exercises targeting it. The idea is to simulate real tasks that someone in this job would encounter, thereby practicing that skill in context. Here are some examples for clarity:
Technical Skill Kata: If the job requires a framework (say React for front-end), a kata might have the learner build a small React component or debug a snippet of React code. If database optimization is a needed skill, a kata could present an inefficient SQL query and ask the learner to refactor it for performance, with a test measuring execution time. For machine learning, a kata might involve improving the accuracy of a given model on a sample dataset, thus practicing ML techniques. The key is authenticity – the kata scenario should mirror how the skill is used on the job (e.g., optimizing a query in a realistic application scenario, not just a toy example).
Problem-Solving/Scenario Kata: Many senior roles expect architecture or system design capabilities. If the posting mentions designing systems or scaling applications, we can include an architecture kata. For instance, provide a high-level problem (“Design a system to handle 1 million requests/day for an e-commerce site”) and ask the learner to outline an architecture. This is similar to known Architecture Katas, which let engineers practice designing systems in a risk-free environment
blog.nimblepros.com
. The kata would provide a scenario (business context and requirements) and prompt the learner to produce a design (which could be reviewed against key points or compared to an expert solution).
Debugging/Troubleshooting Kata: If the job expects maintaining or debugging existing systems (common for senior roles), we create katas around reading and fixing code. For example, the kata could provide a code snippet or log output from a failing application and ask the learner to identify and fix the bug. This practices reading comprehension of code and problem isolation. The scenario might say, "You're on-call and receiving an alert that service X is failing under load – here is the log, here is the code; find the issue and propose a fix." This aligns with real-world tasks and builds diagnostic skills.
Domain/Soft Skill Kata: If domain knowledge is key (say the job is in healthcare tech, or finance), we incorporate context in the scenarios to make them domain-relevant. The kata might not directly teach the domain theory, but it can frame problems in that context (e.g., designing a database for medical records). For soft skills like communication or teamwork (if mentioned in the posting), we can create reflective katas or role-play scenarios – e.g., “Code Review Kata” where the learner has to critique a piece of code constructively, or “Agile Planning Kata” where they must break a project story into tasks. These are more unusual but can be valuable for rounding out preparation.
Each kata is delivered with the Context–Prompt–Spec structure. For example, a kata for API security might look like:
Scenario: “You have joined a team building a fintech application. The job posting emphasized API security and compliance. In this kata, you are presented with a simple Flask API that has security flaws (e.g., missing input validation and no authentication on a sensitive endpoint).”
Prompt: “Identify and fix the security vulnerabilities in the provided API code. Ensure that inputs are validated and that the sensitive endpoint requires proper authentication. You may modify the code and add any necessary checks.”
Specifications/Criteria: “The fixed API should pass all security test cases: (1) It rejects malicious inputs (demonstrated by provided unit tests for SQL injection/XSS), (2) Protected endpoints return 401 Unauthorized when accessed without credentials, (3) All original functionality still works.” (We would include automated tests or at least a checklist to verify these specs.)
The above kata would directly train a skill explicitly mentioned in the posting (API security in fintech). By going through it, the learner engages in deliberate practice on a job-relevant task. 3. Progression and Integration: Once we have katas for individual skills, we arrange them in a logical learning order. A typical progression for a mid/senior role might start with refreshers on core knowledge, then move to more complex, integrative tasks:
Early katas ensure foundational proficiency (e.g., first kata: implement a simple feature in the core technology of the job, to get familiar with syntax and basic patterns).
Middle katas ramp up complexity or combine two skills (e.g., integrate the front-end and back-end: build a small end-to-end feature, or use a tool chain like CI/CD if the job calls for DevOps knowledge).
Late-stage katas simulate the job itself. For instance, a final capstone kata might be a mini-project: “Given a spec similar to what this job’s project entails, implement and deploy the feature.” This could incorporate writing code, writing tests, making design decisions, etc., covering multiple skill areas in one project scenario. It challenges the learner to bring everything together, just as a senior engineer would have to in a real project.
Throughout this progression, context engineering principles are applied to keep the content relevant and appropriately challenging. We feed the learner the right context at the right time. Early on, we might provide more guidance or even reference material (e.g., a cheat sheet for a framework, or a link to documentation) within the kata description to help them succeed. As they progress, we trim down the provided help, forcing them to recall or research as they would on the job. This echoes how AI systems are given supporting context: we include “documentation” or previous conversation history early on (for humans, that might be reminders or hints), and later let them operate with minimal context to test true fluency
datacamp.com
datacamp.com
. 4. Example (Hypothetical): To solidify the concept, imagine a job posting for a Senior Full-Stack Developer requiring: JavaScript/React, Python/Django, SQL performance tuning, and cloud deployment. A kata progression for this could be:
Kata 1: React Component Kata – Build a simple React component per given spec. (Focus: UI skills, state management basics; immediate feedback via snapshot tests.)
Kata 2: Django API Kata – Complete a Django view and model to implement a new API endpoint. (Focus: back-end logic, Django framework; feedback via provided unit tests.)
Kata 3: SQL Optimization Kata – Given a slow SQL query from the existing code, refactor it or add indexes to improve its runtime. (Focus: database tuning; feedback via query benchmark comparison
katanation.com
katanation.com
.)
Kata 4: Integrated Feature Kata – End-to-end task: add a feature where the React frontend talks to the new Django API endpoint. (Focus: integration, full-stack thinking; feedback via end-to-end test or manual verification instructions.)
Kata 5: Deployment/Cloud Kata – Write an infrastructure-as-code script or config to deploy the app (or troubleshoot a provided broken deployment config). (Focus: DevOps skills; feedback via the app successfully running in a test environment.)
Kata 6: Architecture Scenario Kata – Design a scalable architecture for a hypothetical new module in the product (e.g., real-time notifications), considering the tech stack. (Focus: system design and trade-offs; feedback via comparison with an expert design or key points the design should cover, evaluated by a senior mentor or rubric.)
Kata 7: Firefighting Debug Kata – Simulate a production issue: the web app is timing out under load. The kata provides logs and snippets. Task: diagnose the bottleneck (maybe a specific query or misconfiguration) and suggest a fix. (Focus: troubleshooting under pressure; feedback via an explanation of the root cause and solution.)
This sequence starts with specific, constrained tasks and ends with open-ended, high-level tasks, covering all major requirements of the job. By completing these, the learner would effectively rehearse the job. They would enter the role with much stronger confidence and competence, having “practiced” the kinds of work expected. This directly addresses the user’s goal of fast-tracking competency: we compress months of on-the-job learning into a structured module of exercises. The difference is deliberate practice in a safe environment versus learning by trial and error on the job (which is slower and riskier). As one source put it, code katas offer a chance to get ready for the project, to know what to expect and how to handle it – like a pilot using a flight simulator instead of flying blind
apiumhub.com
.
Applying the Framework to Code Repositories
Now, let’s consider a code repository (for example, an open-source project on GitHub or a company’s internal repo) as the content source. The aim here is to create katas that help a developer learn from the repository or get up to speed with it. This is particularly useful for onboarding onto a new project or for self-study using real-world code. 1. Repository Analysis and Context Extraction: We begin by analyzing the repository to understand its context and learning opportunities. Key steps include:
Reading the README and documentation to grasp the project’s purpose, architecture, and usage. This gives high-level context (what the project does, main components).
Scanning the code structure (folders, modules) to identify important sections of the codebase (e.g., core modules, complex algorithms, areas with many recent changes or bugs). This is akin to how an autonomous agent like RepoMaster maps a project’s structure with call graphs and dependency graphs to find core components
arxiv.org
arxiv.org
.
Looking at issue trackers or commit history for common problem areas or recently added features – these often highlight good learning cases (e.g., a tricky bug that was fixed can become a kata scenario: “reproduce and fix this bug”).
Because real repositories are large and complex, a crucial part of our strategy is selecting relevant context for each exercise. We do not want to overwhelm the learner by dumping the entire repository on them at once (just as LLMs struggle with too much code context
arxiv.org
). Instead, we isolate smaller pieces for focused practice. In other words, we curate the “slice” of the repository that the kata will be about. This might mean extracting a single file or function, or a small set of files that relate to one feature. By narrowing scope, we mimic how an expert would learn a new codebase: step by step, not all at once
arxiv.org
. 2. Designing Katas from the Code: Based on the analysis, we identify specific learning tasks. Some types of katas well-suited to code repositories are:
Code Comprehension Kata: These exercises build the skill of understanding and navigating unfamiliar code (a critical skill for mid/senior devs). For example, “Explain What This Function Does” – we present a non-trivial function or class from the repo and ask the learner to read through it and answer questions about its behavior or purpose. The prompt might be: “Given the following function (excerpted from the project), describe in your own words what it does and why it’s implemented that way. Identify its inputs, outputs, and any potential edge cases or bugs.” The spec could include specific questions the learner must answer or tests (e.g., the function’s output for certain inputs to verify understanding). This kata forces the learner to dive into the code logic and possibly the domain (since understanding the code might require understanding the domain terminology used in the code). It’s a form of deliberate practice for code reading, which is often neglected.
Refactoring Kata: Find a piece of code that is messy or outdated (many large codebases have some spaghetti or technical debt). Create a kata where the learner must refactor that code to improve readability, performance, or maintainability without changing its external behavior. We provide the code snippet (and perhaps tests to ensure behavior stays the same). The prompt could be: “Refactor the following class to reduce its complexity and follow best practices (e.g., SOLID principles). The functionality should remain identical – all tests must still pass after refactoring.” The kata then gives a before-and-after scenario. This exercise practices clean code skills. It’s tech-agnostic: the same concept applies whether it’s a Java class or a JavaScript module.
Bug Fix Kata: If there’s a known bug or a recent bug-fix commit in the repo, that’s perfect kata material. Recreate the situation of the bug: give the learner the relevant part of the code and a failing test or bug report. Ask them to diagnose and fix the bug. For instance: “Users report that the application crashes when uploading an image larger than 5MB. In the image processing module below, find and fix the issue causing this crash.” The context might include the stack trace or error message, and the code snippet for the image processing function. The specification is straightforward: “The bug is resolved if images up to 10MB can be uploaded without error (see provided test cases) and no new issues are introduced (all regression tests passing).” This kata closely mimics a day in the life of a maintainer: reading error logs, reading code, and patching it.
Feature Addition Kata: Have the learner implement a small new feature or improvement in the codebase. For open-source repos, this could even be a real “good first issue” that we repurpose into a kata. For example: “Add a caching layer to the getData() function to avoid redundant database calls. Below is the current implementation; modify it to cache results in memory for subsequent calls. Ensure that all existing tests still pass, and add a new test to verify the caching behavior.” This kata involves reading existing code, understanding the intended extension, and writing new code that integrates well – all valuable skills for a contributing developer. The scenario can be framed as “a user requested an enhancement” or “the team lead asked for a performance improvement in this part of the code.”
Integration/Workflow Kata: For a broader challenge, we can create a scenario where the learner has to perform a workflow with the repo: for example, “Fork this repository, apply a series of changes (which we specify), run the test suite, and open a pull request with your changes.” This can be a guided multi-step kata that teaches tools and processes (version control, CI, code review) in addition to coding. The workflow deliverable here is crucial – we might outline steps such as “Step 1: Run the project and observe behavior X. Step 2: Implement change Y in module Z. Step 3: Run tests and ensure they pass. Step 4: Draft a PR message explaining your change.” This kind of kata ensures the learner is not only comfortable with the code but also with the surrounding practices needed in real projects. 3. Managing Context and Difficulty: Similar to the job posting approach, we sequence these repository katas from easier to harder:
Start with passive understanding (read/explain code) before active modification. It’s easier to answer questions about code than to write new code in a large unfamiliar codebase, so comprehension katas come early.
Then move to localized changes (fix a bug in one place, or refactor a small module). This requires deeper understanding but is still constrained to a specific part of the code.
Finally, tackle bigger or cross-cutting changes (add a feature, or refactor an architecture concern across multiple modules). These later katas mimic making a substantial contribution to the project, requiring integration of knowledge from earlier steps.
Throughout, we apply context engineering by providing just the necessary snippets or documentation at each stage, not the whole repo. The katas might come with an appendix or reference for the code context: for instance, if the function uses an object from another module, the kata description might include a brief summary or the interface of that object so the learner isn’t completely lost. Essentially, we feed the learner’s “context window” with relevant slices of the repository, much as an AI agent would retrieve only pertinent code chunks when solving a larger coding task
arxiv.org
. This helps maintain focus and prevents frustration. 4. Example (Hypothetical Repository): Imagine an open-source project “ShopEasy” (an e-commerce web app). A kata progression for onboarding a developer to this project could be:
Kata A: Code Tour & Diagram Kata – After reading the README, draw a simple architecture diagram or outline the responsibilities of each major module in ShopEasy. (This ensures the learner processed the high-level context. It could be presented as a quiz or open-ended task with a provided solution diagram to compare.)
Kata B: Comprehension Kata – Cart Module: Read the CartService class code (given in the prompt) and answer questions: What happens when an item is added to the cart? How are pricing rules applied? Identify one potential edge-case bug in the logic. (Focus: static reading, understanding business logic.)
Kata C: Bug Fix Kata – Checkout Rounding Error – There's a known issue that totals are sometimes off by $0.01 due to rounding. The kata provides the related code snippet and a failing test. Task: fix the rounding error in the calculateTotal() function. (Focus: localized debugging; feedback via test passing.)
Kata D: Feature Kata – Add Wishlist – Implement a new feature to allow users to add items to a Wishlist. Skeleton classes and a brief spec are provided. (This is bigger: touches database (to save wishlist), UI (to display it), etc., but we might stub parts to keep it manageable. It practices adding a feature in a structured way.)
Kata E: Refactor Kata – Order Processor – Refactor the OrderProcessor component which is very long and hard to maintain. Break it into smaller functions or classes as appropriate. (Focus: clean code at an architectural level; feedback via code review checklist or ensuring all unit tests still pass after refactor.)
Kata F: Integration/CI Kata – Set up the project locally, run all tests, then create a small change (e.g., update a dependency or fix a typo) and go through the Git workflow to push the change. (Focus: environment, tooling, and making sure they can navigate and build the project.)
By completing these, the learner gains a working understanding of the repository’s structure and functionality, has practiced solving real issues in it, and is comfortable making changes. Essentially, they’ve walked the path from newcomer to contributor in a guided manner. One could automate some of this kata generation using an LLM: for example, use an AI agent to read the repo and propose questions or tasks (there’s research like RepoMaster focusing on enabling AI to navigate code repositories
arxiv.org
arxiv.org
). But even without full automation, our framework itself is a form of context engineering for learning: we take the raw context (the repository code and docs) and assemble from it a training curriculum—the right snippets, the right questions, the right sequence—so that a human (or AI tutor guiding a human) can effectively learn from that context.
Framework Deliverables: Prompts, Specs, Scenarios, Workflows
For each kata exercise produced (whether from a job posting or repo), we will package the content in a clear, structured format. This is both for clarity to the learner and for potential use in AI-driven tutoring systems. The main components (deliverables) of a kata module are:
Scenario/Context: A background narrative or setting for the exercise. This establishes why the task matters and any initial data or information the learner needs. For example, “You are a new backend engineer at FinTech Inc., working on the payments module…” or “The following code is part of an open-source library for image processing…”. The scenario may include relevant fragments of content (like a portion of a job description or code) that serve as input context. In AI terms, this is analogous to the system and background info that we feed into the prompt
datacamp.com
. In human terms, it helps the learner mentally situate the problem.
Prompt/Challenge: The specific task or question the learner must address. This is often a single command or question, possibly with sub-steps. It should be action-oriented (e.g., “Implement X”, “Fix Y”, “Design Z”) and clearly state the expected output or result (code, design document, answered questions, etc.). We craft prompts to be unambiguous and aligned with the scenario. If multiple steps are required, the prompt can be numbered or broken down for clarity. The prompt is essentially the “what to do” part.
Specifications/Acceptance Criteria: Measurable criteria that define success for the kata. This ensures the learner (and any automated checker) knows when the solution is correct. Specifications can include:
Functional requirements (e.g., “Function must return X given Y” or “Design must handle 1000 requests per second”).
Constraints (e.g., “Use only standard library”, “Follow PEP8 style guidelines”).
Tests that will be run (we might provide a test suite for coding katas).
Evaluation rubrics for design/architecture tasks (key points the solution should cover).
Essentially, this is the “definition of done.” It provides immediate feedback when possible. For instance, “All unit tests in tests/payment_tests.py should pass” is a clear spec. Or for a design kata, “Your design should address scalability and security – e.g., by including a load balancer and encryption (see discussion for expected elements).” By listing specs, we connect to the deliberate practice requirement of feedback: the learner can check against these specs to self-evaluate.
Workflow/Guidance (if necessary): Some complex exercises might benefit from a brief suggested workflow or hints. This is optional and used sparingly, primarily for very open-ended tasks or multi-step processes. For example, an architecture kata might include: “Recommended workflow: (1) List the functional requirements from the scenario. (2) Identify 3-5 key quality attributes (e.g., performance, security)
blog.nimblepros.com
. (3) Sketch a component diagram… etc.” This guides the learner on how to approach the problem without giving away the solution. Another use of workflow could be a hint system: e.g., “Hint: consider what happens if the input is null (click for hint)” – though if this were an interactive module. In a static write-up, we might just include a section like Hint: after the prompt that the learner can choose to read or not. The goal is to provide scaffolding for those who need it, while allowing advanced learners to ignore hints if they prefer the challenge.
Solution (for instructors or self-check): Not typically given to the learner upfront, but we would develop an example solution or at least detailed solution notes for each kata. This could be used by an instructor or by the learner after attempting the kata, to compare their answer. It’s part of the module content, though not presented until after the attempt. For an AI-based system, the AI might generate a solution on demand or check the user’s solution.
We can present these components in Markdown format for readability, or in YAML/JSON for structured programmatic use. Markdown is great for a human-facing workbook (with headings, bullet points, code blocks for snippets, etc.), following the logical flow we’ve outlined. YAML is useful if we want to store and manipulate these kata definitions in a database or use them in an application (since it’s easily parsed). For example, here’s how a kata might be represented in a simplified YAML structure (for illustration):
yaml
Copy
Edit

- title: "Secure API Endpoint Kata"
  level: Senior
  scenario: |
  You are a backend engineer at HealthCo. The API endpoint below is used to retrieve patient records,
  but it was written hastily and has security flaws (no authentication and vulnerable to SQL injection).
  `     @app.route('/records')
    def get_records():
        patient_id = request.args.get('id')
        query = f"SELECT * FROM records WHERE patient_id = {patient_id}"
        return db.execute(query)
    `
  Your task is to secure this endpoint.
  prompt: |
  Refactor the given API code to address the security issues: 1. Implement proper authentication/authorization so only authorized users can access records. 2. Prevent SQL injection attacks on the database query. 3. Ensure the endpoint still returns the correct data for valid requests.
  specifications: - "Unauthenticated requests should be rejected (HTTP 401)." - "SQL queries should use parameterized statements (no string concatenation with user input)." - "Functionality should remain: authorized users get correct records; unauthorized get none." - "All provided security tests must pass."
  hints: - "Think about using an auth token or session check from the request headers." - "Use prepared statements or an ORM query with placeholders for the SQL."
  In the above YAML snippet, we structure the kata with title, level, scenario (including an embedded code block as part of the description), prompt (broken into sub-steps for clarity), specifications (a list of criteria), and hints (which a learning system might reveal on request). This is just one possible schema – the actual format can be adjusted, but the idea is to capture all essential pieces in a machine-readable way. This could then be converted to Markdown for display, or ingested by a tutoring system. The Markdown version of the same might have the code block formatted nicely and each part under subheadings “Scenario”, “Task”, “Specifications”, etc., which makes it easy for a human to follow. By having a consistent format (whether YAML or Markdown), we ensure the katas are reproducible and shareable. In a collaborative setting, instructors or mentors could contribute new kata modules simply by following the template. For AI-assisted generation, the structure tells the AI exactly how to output the content (for instance, an AI prompt could be: “Given the following job posting, generate a YAML with fields: scenario, prompt, specifications, etc., for a kata addressing one of the required skills.” – this is how context engineering could guide AI to help build the curriculum).
  Benefits and Expected Outcomes
  The proposed kata progression system framework, when applied to job postings and code repositories, yields multiple benefits:
  Accelerated Skill Development: By focusing training on exactly what the end user needs (as derived from job descriptions or code analysis) and using deliberate practice routines, learners can ramp up much faster than with generic courses. They are essentially practicing the job before having the job. This targeted practice can shorten the time needed to reach proficiency in a role. (In fact, organizations that adopted kata-based learning saw significant improvements in developer skill maturity and even doubled productivity in some cases
  katanation.com
  , thanks to the focus and efficiency of practice.)
  Confidence through Experience: One of the hardest parts of starting a new job or project is the lack of confidence: “Have I ever done something like this before?” Kata modules give the learner pseudo-experience. By solving similar problems in a no-stakes environment, they build muscle memory. So a mid-level developer facing, say, their first major refactoring in a legacy codebase will recall the kata where they refactored a messy module and approach the real task with a proven strategy.
  Contextual Knowledge Retention: Since our framework is context-rich (especially for code repo katas, where you learn the actual code structure), the learner retains a map of the context. For a job posting, this means they deeply understand what the job may entail (great for interviewing, too, as they can speak from practice). For a repository, it means the onboarding person actually learns the architecture and idioms of the codebase, not just theory. They’ve touched the code in a guided way, which makes them productive sooner.
  Adaptability and Reusability: Because the system is tech-agnostic, we can apply it broadly. It could generate kata curricula for a data scientist role by focusing on tasks like cleaning data, training models, etc., or for a DevOps engineer by focusing on writing CI pipelines and debugging deployments. The framework doesn’t change – only the content does. Likewise, for repositories, whether it’s a front-end JS project or a low-level C library, the approach (comprehension, small changes, bigger changes) holds. This means an organization could standardize this learning approach across teams and domains.
  Integrated “Context Engineering” for AI Tutors: If this framework is used in conjunction with AI (for example, an AI mentor that presents these katas to users, or even ChatGPT-based guidance during the kata), it demonstrates good context engineering practice. We assemble all the needed pieces (instructions, background, examples, tools like test cases) into the prompt or interface for the learner/AI. This reduces confusion and makes the learning interaction more effective
  datacamp.com
  datacamp.com
  . Essentially, we’re engineering the learning context meticulously, which is analogous to how one would feed a comprehensive context to an AI system to get a high-quality result
  datacamp.com
  . In our case, the “result” is the learner’s improved competency.
  In conclusion, the kata progression system for job postings and code repos is a powerful framework for deliberate, context-rich learning. It takes the art of deliberate practice – focused, repeated, feedback-driven exercise
  katanation.com
  – and wraps it in the real-world context of the target content. The outcome is a set of “Context Engineering” deliverables (scenarios, prompts, specs, workflows) that together form a full learning module. By following these modules, a mid-level or senior learner can rapidly align their skills with the demands of a new job or project. They don’t just learn in theory – they practice in context, which is the fastest path to competency. Sources:
  Apiumhub Tech Blog – What is Code Kata? (Dave Thomas’s concept of code kata and its goals)
  apiumhub.com
  apiumhub.com
  apiumhub.com
  apiumhub.com
  KataNation – Kata Culture (Principles of kata-based learning: deliberate practice, scaffolding, rules, progression stages)
  katanation.com
  katanation.com
  katanation.com
  PremierAgile – Toyota Kata & Improvement Kata (Breaking down complex goals into smaller targets, practicing routines to build skill until habits form)
  premieragile.com
  premieragile.com
  Autonomy Data Unit Blog – Skills Extraction with LLMs (On extracting skill requirements from job postings using NLP)
  adu.autonomy.work
  NimblePros Blog – Practicing Architecture Katas (Example of kata for software architecture, highlighting scenario-based group practice)
  blog.nimblepros.com
  Wang et al., RepoMaster (2025) – (Research on an AI agent understanding code repositories; inspires our approach to focus on core components and progressive exploration of code)
  arxiv.org
  arxiv.org
  DataCamp – Context Engineering: A Guide (Introduction of context engineering – designing what information a model sees; analogous to how we assemble learning context for our katas)
